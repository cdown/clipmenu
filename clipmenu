#!/usr/bin/env bash

: "${CM_HISTLENGTH=8}"

shopt -s nullglob

cache_dir=$(clipctl cache-dir)
cache_file=$cache_dir/line_cache

# Not -h, see #142
if [[ $1 == --help ]]; then
    cat << 'EOF'
clipmenu is a simple clipboard manager using dmenu and xsel. Launch this
when you want to select a clip.

All arguments are passed through to dmenu itself.

Environment variables:

- $CM_DIR: specify the base directory to store the cache dir in (default: $XDG_RUNTIME_DIR, $TMPDIR, or /tmp)
- $CM_HISTLENGTH: specify the number of lines to show in dmenu/rofi (default: 8)
- $CM_LAUNCHER: specify the name or path of a supported launcher (default: dmenu)
- $CM_LAUNCHER_TYPE: the type of launcher implementation (supported: dmenu, fzf, custom, rofi, rofi-script; default: dmenu)
- $CM_OUTPUT_CLIP: if set, output clip selectikn to stdout
EOF
    exit 0
fi

if ! [[ -f "$cache_file" ]]; then
    printf '%s\n' 'No cache file yet, did you run clipmenud?'
    exit 2
fi

# Blacklist of non-dmenu launchers
dmenu_launcher_args=(-l "${CM_HISTLENGTH}")
fzf_launcher_args=()

# rofi supports dmenu-like arguments through the -dmenu flag. -p wastes space
# in real dmenu, but rofi shows "dmenu:" anyway, so pass it here only.
rofi_launcher_args=(-dmenu -p clipmenu "${dmenu_launcher_args[@]}")

run_launcher() {
    "${CM_LAUNCHER?internal error: CM_LAUNCHER must be defined}" "$@"
}

invoke_dmenu_launcher() {
    run_launcher "${dmenu_launcher_args[@]}" "$@"
}

invoke_fzf_launcher() {
    run_launcher "${fzf_launcher_args[@]}" "$@"
}

invoke_rofi_launcher() {
    run_launcher "${rofi_launcher_args[@]}" "$@"
}

invoke_custom_launcher() {
    local dmenu_args fzf_args rofi_args

    printf -v dmenu_args '%q ' "${dmenu_launcher_args[@]}"
    printf -v fzf_args '%q ' "${fzf_launcher_args[@]}"
    printf -v rofi_args '%q ' "${rofi_launcher_args[@]}"

    CM_DMENU_ARGS="$dmenu_args" \
        CM_FZF_ARGS="$fzf_args" \
        CM_ROFI_ARGS="$rofi_args" \
        run_launcher "$@"
}

invoke_launcher() {
    "invoke_${CM_LAUNCHER_TYPE?internal error: CM_LAUNCHER_TYPE must be defined}_launcher" "$@"
}

list_clips() {
    LC_ALL=C sort -rnk 1 < "$cache_file" | cut -d' ' -f2- | awk '!seen[$0]++'
}

case "${CM_LAUNCHER_TYPE:-}" in
    dmenu|fzf|rofi|rofi-script)
        # NOP
        ;;
    custom)
        if ! [[ -v CM_LAUNCHER ]]; then
            printf 1>&2 -- "CM_LAUNCHER must be set when using CM_LAUNCHER_TYPE 'custom'\\n"
            exit 2
        fi
        ;;
    *)
        if [[ -v CM_LAUNCHER ]]; then
            launcher_type="${CM_LAUNCHER##*/}"
        fi

        case "${launcher_type:-}" in
            dmenu|fzf|rofi)
                # NOP
                ;;
            *)
                if [[ -v ROFI_RETV ]]; then
                    launcher_type=rofi-script
                else
                    launcher_type=dmenu
                fi
                ;;
        esac

        if [[ "$launcher_type" != "${CM_LAUNCHER_TYPE:-}" ]]; then
            if [[ -v CM_LAUNCHER_TYPE ]]; then
                printf 1>&2 -- "Unrecognized CM_LAUNCHER_TYPE '%s'; assuming '%s'-type launcher.\\n" \
                    "$CM_LAUNCHER_TYPE" "$launcher_type"
            fi

            CM_LAUNCHER_TYPE="$launcher_type"
        fi
        ;;
esac

# If we've gotten this far and CM_LAUNCHER is unset, then we know that
# CM_LAUNCHER_TYPE contains one of "dmenu", "fzf", "rofi", or "rofi-script",
# which is also a safe and appropriate value for CM_LAUNCHER.
: "${CM_LAUNCHER="$CM_LAUNCHER_TYPE"}"

# https://github.com/davatorium/rofi/blob/38c102d63b51488299fad4189beb5bbf3e7ca5ae/doc/rofi-script.5.markdown
if [[ "$CM_LAUNCHER_TYPE" == rofi-script ]]; then
    # See this for how to to set rofi options while in script mode:
    # https://github.com/davatorium/rofi/blob/38c102d63b51488299fad4189beb5bbf3e7ca5ae/doc/rofi-script.5.markdown#passing-mode-options

    # Set the rofi prompt to "clipmenu"
    printf -- '\0prompt\x1fclipmenu\n'

    # Disable custom input; user may only select a listed entry -- since we
    # list all available clipboard selections, a query result that doesn't
    # match anything will cause this script to exit (a) with a nonzero value
    # and (b) without putting anything into the selection buffers.
    printf -- '\0no-custom\x1ftrue\n'

    if (( $# )); then
        chosen_line="${!#}"
    else
        list_clips
        exit
    fi
else
    chosen_line=$(list_clips | invoke_launcher "$@")
    launcher_exit=$?
fi

[[ $chosen_line ]] || exit 1
file=$cache_dir/$(cksum <<< "$chosen_line")
[[ -f "$file" ]] || exit 2

for selection in clipboard primary; do
    xsel --logfile /dev/null -i --"$selection" < "$file"
done

if (( CM_OUTPUT_CLIP )); then
    cat "$file"
fi

exit "${launcher_exit:-"$?"}"
